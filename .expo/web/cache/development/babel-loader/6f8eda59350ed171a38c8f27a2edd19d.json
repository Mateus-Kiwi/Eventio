{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { State } from \"../../State\";\nimport GestureHandler from \"./GestureHandler\";\n\nvar NativeViewGestureHandler = function (_GestureHandler) {\n  _inherits(NativeViewGestureHandler, _GestureHandler);\n\n  var _super = _createSuper(NativeViewGestureHandler);\n\n  function NativeViewGestureHandler() {\n    var _this;\n\n    _classCallCheck(this, NativeViewGestureHandler);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"buttonRole\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"disallowInterruption\", false);\n\n    return _this;\n  }\n\n  _createClass(NativeViewGestureHandler, [{\n    key: \"init\",\n    value: function init(ref, propsRef) {\n      _get(_getPrototypeOf(NativeViewGestureHandler.prototype), \"init\", this).call(this, ref, propsRef);\n\n      this.setShouldCancelWhenOutside(true);\n\n      if (!this.view) {\n        return;\n      }\n\n      this.view.style['touchAction'] = 'auto';\n      this.view.style['webkitUserSelect'] = 'auto';\n      this.view.style['userSelect'] = 'auto';\n      this.view.style['WebkitTouchCallout'] = 'auto';\n\n      if (this.view.hasAttribute('role')) {\n        this.buttonRole = true;\n      } else {\n        this.buttonRole = false;\n      }\n    }\n  }, {\n    key: \"resetConfig\",\n    value: function resetConfig() {\n      _get(_getPrototypeOf(NativeViewGestureHandler.prototype), \"resetConfig\", this).call(this);\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(event) {\n      _get(_getPrototypeOf(NativeViewGestureHandler.prototype), \"onPointerDown\", this).call(this, event);\n\n      this.tracker.addToTracker(event);\n\n      if (this.currentState === State.UNDETERMINED) {\n        this.begin(event);\n\n        if (this.buttonRole) {\n          this.activate(event);\n        }\n      }\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(_event) {}\n  }, {\n    key: \"onPointerOut\",\n    value: function onPointerOut(event) {\n      this.cancel(event);\n    }\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(event) {\n      this.tracker.removeFromTracker(event.pointerId);\n\n      if (!this.buttonRole) {\n        this.activate(event);\n      }\n\n      if (this.tracker.getTrackedPointersCount() === 0) {\n        this.end(event);\n      }\n    }\n  }, {\n    key: \"onPointerCancel\",\n    value: function onPointerCancel(event) {\n      this.cancel(event);\n      this.reset();\n    }\n  }, {\n    key: \"shouldRecognizeSimultaneously\",\n    value: function shouldRecognizeSimultaneously(handler) {\n      if (_get(_getPrototypeOf(NativeViewGestureHandler.prototype), \"shouldRecognizeSimultaneously\", this).call(this, handler)) {\n        return true;\n      }\n\n      if (handler instanceof NativeViewGestureHandler && handler.getState() === State.ACTIVE && handler.disallowsInterruption()) {\n        return false;\n      }\n\n      var canBeInterrupted = !this.disallowInterruption;\n\n      if (this.currentState === State.ACTIVE && handler.getState() === State.ACTIVE && canBeInterrupted) {\n        return false;\n      }\n\n      return this.currentState === State.ACTIVE && canBeInterrupted && handler.getTag() > 0;\n    }\n  }, {\n    key: \"shouldBeCancelledByOther\",\n    value: function shouldBeCancelledByOther(_handler) {\n      return !this.disallowInterruption;\n    }\n  }, {\n    key: \"disallowsInterruption\",\n    value: function disallowsInterruption() {\n      return this.disallowInterruption;\n    }\n  }]);\n\n  return NativeViewGestureHandler;\n}(GestureHandler);\n\nexport { NativeViewGestureHandler as default };","map":{"version":3,"sources":["NativeViewGestureHandler.ts"],"names":["init","resetConfig","onPointerDown","State","onPointerMove","onPointerOut","onPointerUp","event","onPointerCancel","shouldRecognizeSimultaneously","handler","canBeInterrupted","shouldBeCancelledByOther","disallowsInterruption"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,KAAA;AAGA,OAAA,cAAA;;IACe,wB;;;;;EAAsD,oCAAA;IAAA;;IAAA;;IAAA,kCAAA,IAAA;MAAA,IAAA;IAAA;;IAAA,gDAAA,IAAA;;IAAA,eAAA,gCAAA,YAAA,EAAA,KAAA,CAAA,CAAA;;IAAA,eAAA,gCAAA,sBAAA,EAAA,KAAA,CAAA;;IAAA;EAAA;;;;WAK5DA,cAAI,GAAJA,EAAI,QAAJA,EAA4D;MACjE,mFAAA,GAAA,EAAA,QAAA;;MAEA,KAAA,0BAAA,CAAA,IAAA;;MAEA,IAAI,CAAC,KAAL,IAAA,EAAgB;QACd;MACD;;MAED,KAAA,IAAA,CAAA,KAAA,CAAA,aAAA,IAAA,MAAA;MACA,KAAA,IAAA,CAAA,KAAA,CAAA,kBAAA,IAAA,MAAA;MACA,KAAA,IAAA,CAAA,KAAA,CAAA,YAAA,IAXiE,MAWjE;MAGA,KAAA,IAAA,CAAA,KAAA,CAAA,oBAAA,IAAA,MAAA;;MAEA,IAAI,KAAA,IAAA,CAAA,YAAA,CAAJ,MAAI,CAAJ,EAAoC;QAClC,KAAA,UAAA,GAAA,IAAA;MADF,CAAA,MAEO;QACL,KAAA,UAAA,GAAA,KAAA;MACD;IACF;;;WAESC,uBAAoB;MAC5B;IACD;;;WAESC,uBAAa,KAAbA,EAAgD;MACxD,4FAAA,KAAA;;MACA,KAAA,OAAA,CAAA,YAAA,CAAA,KAAA;;MAEA,IAAI,KAAA,YAAA,KAAsBC,KAAK,CAA/B,YAAA,EAA8C;QAC5C,KAAA,KAAA,CAAA,KAAA;;QACA,IAAI,KAAJ,UAAA,EAAqB;UACnB,KAAA,QAAA,CAAA,KAAA;QACD;MACF;IACF;;;WAESC,uBAAa,MAAbA,EAAiD,CAE1D;;;WAESC,sBAAY,KAAZA,EAA+C;MACvD,KAAA,MAAA,CAAA,KAAA;IACD;;;WAESC,qBAAW,KAAXA,EAA8C;MACtD,KAAA,OAAA,CAAA,iBAAA,CAA+BC,KAAK,CAApC,SAAA;;MACA,IAAI,CAAC,KAAL,UAAA,EAAsB;QACpB,KAAA,QAAA,CAAA,KAAA;MACD;;MACD,IAAI,KAAA,OAAA,CAAA,uBAAA,OAAJ,CAAA,EAAkD;QAChD,KAAA,GAAA,CAAA,KAAA;MACD;IACF;;;WAESC,yBAAe,KAAfA,EAAkD;MAC1D,KAAA,MAAA,CAAA,KAAA;MACA,KAAA,KAAA;IACD;;;WAEMC,uCAA6B,OAA7BA,EAAgE;MACrE,gHAAA,OAAA,GAAkD;QAChD,OAAA,IAAA;MACD;;MAED,IACEC,OAAO,YAAPA,wBAAAA,IACAA,OAAO,CAAPA,QAAAA,OAAuBP,KAAK,CAD5BO,MAAAA,IAEAA,OAAO,CAHT,qBAGEA,EAHF,EAIE;QACA,OAAA,KAAA;MACD;;MAED,IAAMC,gBAAgB,GAAG,CAAC,KAA1B,oBAAA;;MAEA,IACE,KAAA,YAAA,KAAsBR,KAAK,CAA3B,MAAA,IACAO,OAAO,CAAPA,QAAAA,OAAuBP,KAAK,CAD5B,MAAA,IADF,gBAAA,EAIE;QACA,OAAA,KAAA;MACD;;MAED,OACE,KAAA,YAAA,KAAsBA,KAAK,CAA3B,MAAA,IAAA,gBAAA,IAEAO,OAAO,CAAPA,MAAAA,KAHF,CAAA;IAKD;;;WAEME,kCAAwB,QAAxBA,EAA4D;MACjE,OAAO,CAAC,KAAR,oBAAA;IACD;;;WAEMC,iCAAiC;MACtC,OAAO,KAAP,oBAAA;IACD;;;;EAvGY,c;;SAAA,wB","sourcesContent":["import { State } from '../../State';\nimport { AdaptedPointerEvent } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nexport default class NativeViewGestureHandler extends GestureHandler {\n  private buttonRole!: boolean;\n\n  private disallowInterruption = false;\n\n  public init(ref: number, propsRef: React.RefObject<unknown>): void {\n    super.init(ref, propsRef);\n\n    this.setShouldCancelWhenOutside(true);\n\n    if (!this.view) {\n      return;\n    }\n\n    this.view.style['touchAction'] = 'auto';\n    this.view.style['webkitUserSelect'] = 'auto';\n    this.view.style['userSelect'] = 'auto';\n\n    //@ts-ignore Turns on defualt touch behavior on Safari\n    this.view.style['WebkitTouchCallout'] = 'auto';\n\n    if (this.view.hasAttribute('role')) {\n      this.buttonRole = true;\n    } else {\n      this.buttonRole = false;\n    }\n  }\n\n  protected resetConfig(): void {\n    super.resetConfig();\n  }\n\n  protected onPointerDown(event: AdaptedPointerEvent): void {\n    super.onPointerDown(event);\n    this.tracker.addToTracker(event);\n\n    if (this.currentState === State.UNDETERMINED) {\n      this.begin(event);\n      if (this.buttonRole) {\n        this.activate(event);\n      }\n    }\n  }\n\n  protected onPointerMove(_event: AdaptedPointerEvent): void {\n    //\n  }\n\n  protected onPointerOut(event: AdaptedPointerEvent): void {\n    this.cancel(event);\n  }\n\n  protected onPointerUp(event: AdaptedPointerEvent): void {\n    this.tracker.removeFromTracker(event.pointerId);\n    if (!this.buttonRole) {\n      this.activate(event);\n    }\n    if (this.tracker.getTrackedPointersCount() === 0) {\n      this.end(event);\n    }\n  }\n\n  protected onPointerCancel(event: AdaptedPointerEvent): void {\n    this.cancel(event);\n    this.reset();\n  }\n\n  public shouldRecognizeSimultaneously(handler: GestureHandler): boolean {\n    if (super.shouldRecognizeSimultaneously(handler)) {\n      return true;\n    }\n\n    if (\n      handler instanceof NativeViewGestureHandler &&\n      handler.getState() === State.ACTIVE &&\n      handler.disallowsInterruption()\n    ) {\n      return false;\n    }\n\n    const canBeInterrupted = !this.disallowInterruption;\n\n    if (\n      this.currentState === State.ACTIVE &&\n      handler.getState() === State.ACTIVE &&\n      canBeInterrupted\n    ) {\n      return false;\n    }\n\n    return (\n      this.currentState === State.ACTIVE &&\n      canBeInterrupted &&\n      handler.getTag() > 0\n    );\n  }\n\n  public shouldBeCancelledByOther(_handler: GestureHandler): boolean {\n    return !this.disallowInterruption;\n  }\n\n  public disallowsInterruption(): boolean {\n    return this.disallowInterruption;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}