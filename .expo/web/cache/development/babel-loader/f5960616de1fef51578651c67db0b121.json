{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar _excluded = [\"enabled\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport { State } from \"../../State\";\nimport EventManager from \"../tools/EventManager\";\nimport GestureHandlerOrchestrator from \"../tools/GestureHandlerOrchestrator\";\nimport PointerTracker from \"../tools/PointerTracker\";\n\nvar GestureHandler = function () {\n  function GestureHandler() {\n    var _this = this;\n\n    _classCallCheck(this, GestureHandler);\n\n    _defineProperty(this, \"lastSentState\", null);\n\n    _defineProperty(this, \"currentState\", State.UNDETERMINED);\n\n    _defineProperty(this, \"shouldCancellWhenOutside\", false);\n\n    _defineProperty(this, \"hasCustomActivationCriteria\", void 0);\n\n    _defineProperty(this, \"enabled\", false);\n\n    _defineProperty(this, \"ref\", void 0);\n\n    _defineProperty(this, \"propsRef\", void 0);\n\n    _defineProperty(this, \"config\", {\n      enabled: false\n    });\n\n    _defineProperty(this, \"handlerTag\", void 0);\n\n    _defineProperty(this, \"view\", null);\n\n    _defineProperty(this, \"eventManager\", void 0);\n\n    _defineProperty(this, \"tracker\", new PointerTracker());\n\n    _defineProperty(this, \"interactionManager\", void 0);\n\n    _defineProperty(this, \"activationIndex\", 0);\n\n    _defineProperty(this, \"awaiting\", false);\n\n    _defineProperty(this, \"active\", false);\n\n    _defineProperty(this, \"shouldResetProgress\", false);\n\n    _defineProperty(this, \"sendEvent\", function (event, newState, oldState) {\n      var _this$propsRef$curren = _this.propsRef.current,\n          onGestureHandlerEvent = _this$propsRef$curren.onGestureHandlerEvent,\n          onGestureHandlerStateChange = _this$propsRef$curren.onGestureHandlerStateChange;\n\n      var resultEvent = _this.transformEventData(event, newState, oldState);\n\n      if (_this.lastSentState !== newState) {\n        _this.lastSentState = newState;\n        invokeNullableMethod(onGestureHandlerStateChange, resultEvent);\n      }\n\n      if (_this.currentState === State.ACTIVE) {\n        resultEvent.nativeEvent.oldState = undefined;\n        invokeNullableMethod(onGestureHandlerEvent, resultEvent);\n      }\n    });\n\n    this.hasCustomActivationCriteria = false;\n  }\n\n  _createClass(GestureHandler, [{\n    key: \"init\",\n    value: function init(ref, propsRef) {\n      this.propsRef = propsRef;\n      this.ref = ref;\n      this.currentState = State.UNDETERMINED;\n      this.setView(ref);\n      this.setEventManager();\n    }\n  }, {\n    key: \"setView\",\n    value: function setView(ref) {\n      if (!ref) {\n        this.view = null;\n        return;\n      }\n\n      this.view = findNodeHandle(ref);\n      this.view.style['touchAction'] = 'none';\n      this.view.style['webkitUserSelect'] = 'none';\n      this.view.style['userSelect'] = 'none';\n      this.view.style['WebkitTouchCallout'] = 'none';\n    }\n  }, {\n    key: \"setEventManager\",\n    value: function setEventManager() {\n      if (!this.view) {\n        return;\n      }\n\n      this.eventManager = new EventManager(this.view);\n      this.eventManager.setOnPointerDown(this.onPointerDown.bind(this));\n      this.eventManager.setOnPointerUp(this.onPointerUp.bind(this));\n      this.eventManager.setOnPointerMove(this.onPointerMove.bind(this));\n      this.eventManager.setOnPointerEnter(this.onPointerEnter.bind(this));\n      this.eventManager.setOnPointerOut(this.onPointerOut.bind(this));\n      this.eventManager.setOnPointerCancel(this.onPointerCancel.bind(this));\n      this.eventManager.setOnPointerOutOfBounds(this.onPointerOutOfBounds.bind(this));\n      this.eventManager.setListeners();\n    }\n  }, {\n    key: \"setInteractionManager\",\n    value: function setInteractionManager(manager) {\n      this.interactionManager = manager;\n    }\n  }, {\n    key: \"onCancel\",\n    value: function onCancel() {}\n  }, {\n    key: \"onReset\",\n    value: function onReset() {}\n  }, {\n    key: \"resetProgress\",\n    value: function resetProgress() {}\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.tracker.resetTracker();\n      this.onReset();\n      this.currentState = State.UNDETERMINED;\n    }\n  }, {\n    key: \"moveToState\",\n    value: function moveToState(newState, event) {\n      if (this.currentState === newState) {\n        return;\n      }\n\n      var oldState = this.currentState;\n      this.currentState = newState;\n      GestureHandlerOrchestrator.getInstance().onHandlerStateChange(this, newState, oldState, event);\n      this.onStateChange(newState, oldState);\n    }\n  }, {\n    key: \"onStateChange\",\n    value: function onStateChange(_newState, _oldState) {}\n  }, {\n    key: \"begin\",\n    value: function begin(event) {\n      if (!this.checkHitSlop(event)) {\n        return;\n      }\n\n      if (this.currentState === State.UNDETERMINED) {\n        this.moveToState(State.BEGAN, event);\n      }\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(event) {\n      if (this.currentState === State.ACTIVE || this.currentState === State.BEGAN) {\n        this.moveToState(State.FAILED, event);\n      }\n\n      this.resetProgress();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(event) {\n      if (this.currentState === State.ACTIVE || this.currentState === State.UNDETERMINED || this.currentState === State.BEGAN) {\n        this.onCancel();\n        this.moveToState(State.CANCELLED, event);\n      }\n    }\n  }, {\n    key: \"activate\",\n    value: function activate(event) {\n      var _force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.currentState === State.UNDETERMINED || this.currentState === State.BEGAN) {\n        this.moveToState(State.ACTIVE, event);\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(event) {\n      if (this.currentState === State.BEGAN || this.currentState === State.ACTIVE) {\n        this.moveToState(State.END, event);\n      }\n\n      this.resetProgress();\n    }\n  }, {\n    key: \"isAwaiting\",\n    value: function isAwaiting() {\n      return this.awaiting;\n    }\n  }, {\n    key: \"setAwaiting\",\n    value: function setAwaiting(value) {\n      this.awaiting = value;\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.active;\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive(value) {\n      this.active = value;\n    }\n  }, {\n    key: \"getShouldResetProgress\",\n    value: function getShouldResetProgress() {\n      return this.shouldResetProgress;\n    }\n  }, {\n    key: \"setShouldResetProgress\",\n    value: function setShouldResetProgress(value) {\n      this.shouldResetProgress = value;\n    }\n  }, {\n    key: \"getActivationIndex\",\n    value: function getActivationIndex() {\n      return this.activationIndex;\n    }\n  }, {\n    key: \"setActivationIndex\",\n    value: function setActivationIndex(value) {\n      this.activationIndex = value;\n    }\n  }, {\n    key: \"shouldWaitForHandlerFailure\",\n    value: function shouldWaitForHandlerFailure(handler) {\n      if (handler === this) {\n        return false;\n      }\n\n      return this.interactionManager.shouldWaitForHandlerFailure(this, handler);\n    }\n  }, {\n    key: \"shouldRequireToWaitForFailure\",\n    value: function shouldRequireToWaitForFailure(handler) {\n      if (handler === this) {\n        return false;\n      }\n\n      return this.interactionManager.shouldRequireHandlerToWaitForFailure(this, handler);\n    }\n  }, {\n    key: \"shouldRecognizeSimultaneously\",\n    value: function shouldRecognizeSimultaneously(handler) {\n      if (handler === this) {\n        return true;\n      }\n\n      return this.interactionManager.shouldRecognizeSimultaneously(this, handler);\n    }\n  }, {\n    key: \"shouldBeCancelledByOther\",\n    value: function shouldBeCancelledByOther(handler) {\n      if (handler === this) {\n        return false;\n      }\n\n      return this.interactionManager.shouldHandlerBeCancelledBy(this, handler);\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(_event) {\n      GestureHandlerOrchestrator.getInstance().recordHandlerIfNotPresent(this);\n    }\n  }, {\n    key: \"onPointerAdd\",\n    value: function onPointerAdd(_event) {}\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(_event) {}\n  }, {\n    key: \"onPointerRemove\",\n    value: function onPointerRemove(_event) {}\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(event) {\n      this.tryToSendMoveEvent(event, false);\n    }\n  }, {\n    key: \"onPointerOut\",\n    value: function onPointerOut(_event) {}\n  }, {\n    key: \"onPointerEnter\",\n    value: function onPointerEnter(_event) {}\n  }, {\n    key: \"onPointerCancel\",\n    value: function onPointerCancel(_event) {}\n  }, {\n    key: \"onPointerOutOfBounds\",\n    value: function onPointerOutOfBounds(event) {\n      this.tryToSendMoveEvent(event, true);\n    }\n  }, {\n    key: \"tryToSendMoveEvent\",\n    value: function tryToSendMoveEvent(event, out) {\n      if (this.currentState === State.ACTIVE && (!out || out && !this.shouldCancellWhenOutside)) {\n        this.sendEvent(event, this.currentState, this.currentState);\n      }\n    }\n  }, {\n    key: \"transformEventData\",\n    value: function transformEventData(event, newState, oldState) {\n      var _this$eventManager;\n\n      return {\n        nativeEvent: _objectSpread(_objectSpread({\n          numberOfPointers: this.tracker.getTrackedPointersCount(),\n          state: newState,\n          pointerInside: (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.isPointerInBounds({\n            x: event.x,\n            y: event.y\n          })\n        }, this.transformNativeEvent(event)), {}, {\n          handlerTag: this.handlerTag,\n          target: this.ref,\n          oldState: newState !== oldState ? oldState : undefined\n        }),\n        timeStamp: Date.now()\n      };\n    }\n  }, {\n    key: \"transformNativeEvent\",\n    value: function transformNativeEvent(_event) {\n      return {};\n    }\n  }, {\n    key: \"updateGestureConfig\",\n    value: function updateGestureConfig(_ref) {\n      var _ref$enabled = _ref.enabled,\n          enabled = _ref$enabled === void 0 ? true : _ref$enabled,\n          props = _objectWithoutProperties(_ref, _excluded);\n\n      this.config = _objectSpread({\n        enabled: enabled\n      }, props);\n      this.validateHitSlops();\n    }\n  }, {\n    key: \"checkCustomActivationCriteria\",\n    value: function checkCustomActivationCriteria(criterias) {\n      for (var key in this.config) {\n        if (criterias.indexOf(key) >= 0) {\n          this.hasCustomActivationCriteria = true;\n        }\n      }\n    }\n  }, {\n    key: \"validateHitSlops\",\n    value: function validateHitSlops() {\n      if (!this.config.hitSlop) {\n        return;\n      }\n\n      if (this.config.hitSlop.left !== undefined && this.config.hitSlop.right !== undefined && this.config.hitSlop.width !== undefined) {\n        throw new Error('HitSlop Error: Cannot define left, right and width at the same time');\n      }\n\n      if (this.config.hitSlop.width !== undefined && this.config.hitSlop.left === undefined && this.config.hitSlop.right === undefined) {\n        throw new Error('HitSlop Error: When width is defined, either left or right has to be defined');\n      }\n\n      if (this.config.hitSlop.height !== undefined && this.config.hitSlop.top !== undefined && this.config.hitSlop.bottom !== undefined) {\n        throw new Error('HitSlop Error: Cannot define top, bottom and height at the same time');\n      }\n\n      if (this.config.hitSlop.height !== undefined && this.config.hitSlop.top === undefined && this.config.hitSlop.bottom === undefined) {\n        throw new Error('HitSlop Error: When height is defined, either top or bottom has to be defined');\n      }\n    }\n  }, {\n    key: \"checkHitSlop\",\n    value: function checkHitSlop(event) {\n      if (!this.config.hitSlop || !this.view) {\n        return true;\n      }\n\n      var width = this.view.getBoundingClientRect().width;\n      var height = this.view.getBoundingClientRect().height;\n      var left = 0;\n      var top = 0;\n      var right = width;\n      var bottom = height;\n\n      if (this.config.hitSlop.horizontal !== undefined) {\n        left -= this.config.hitSlop.horizontal;\n        right += this.config.hitSlop.horizontal;\n      }\n\n      if (this.config.hitSlop.vertical !== undefined) {\n        top -= this.config.hitSlop.vertical;\n        bottom += this.config.hitSlop.vertical;\n      }\n\n      if (this.config.hitSlop.left !== undefined) {\n        left = -this.config.hitSlop.left;\n      }\n\n      if (this.config.hitSlop.right !== undefined) {\n        right = width + this.config.hitSlop.right;\n      }\n\n      if (this.config.hitSlop.top !== undefined) {\n        top = -this.config.hitSlop.top;\n      }\n\n      if (this.config.hitSlop.bottom !== undefined) {\n        bottom = width + this.config.hitSlop.bottom;\n      }\n\n      if (this.config.hitSlop.width !== undefined) {\n        if (this.config.hitSlop.left !== undefined) {\n          right = left + this.config.hitSlop.width;\n        } else if (this.config.hitSlop.right !== undefined) {\n          left = right - this.config.hitSlop.width;\n        }\n      }\n\n      if (this.config.hitSlop.height !== undefined) {\n        if (this.config.hitSlop.top !== undefined) {\n          bottom = top + this.config.hitSlop.height;\n        } else if (this.config.hitSlop.bottom !== undefined) {\n          top = bottom - this.config.hitSlop.height;\n        }\n      }\n\n      if (event.offsetX >= left && event.offsetX <= right && event.offsetY >= top && event.offsetY <= bottom) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"resetConfig\",\n    value: function resetConfig() {}\n  }, {\n    key: \"getTag\",\n    value: function getTag() {\n      return this.handlerTag;\n    }\n  }, {\n    key: \"setTag\",\n    value: function setTag(tag) {\n      this.handlerTag = tag;\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.config;\n    }\n  }, {\n    key: \"getShouldEnableGestureOnSetup\",\n    value: function getShouldEnableGestureOnSetup() {\n      throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n    }\n  }, {\n    key: \"getView\",\n    value: function getView() {\n      return this.view;\n    }\n  }, {\n    key: \"getEventManager\",\n    value: function getEventManager() {\n      return this.eventManager;\n    }\n  }, {\n    key: \"getTracker\",\n    value: function getTracker() {\n      return this.tracker;\n    }\n  }, {\n    key: \"getTrackedPointersID\",\n    value: function getTrackedPointersID() {\n      return this.tracker.getTrackedPointersID();\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this.currentState;\n    }\n  }, {\n    key: \"setShouldCancelWhenOutside\",\n    value: function setShouldCancelWhenOutside(flag) {\n      this.shouldCancellWhenOutside = flag;\n    }\n  }, {\n    key: \"getShouldCancelWhenOutside\",\n    value: function getShouldCancelWhenOutside() {\n      return this.shouldCancellWhenOutside;\n    }\n  }]);\n\n  return GestureHandler;\n}();\n\nexport { GestureHandler as default };\n\nfunction invokeNullableMethod(method, event) {\n  if (!method) {\n    return;\n  }\n\n  if (typeof method === 'function') {\n    method(event);\n    return;\n  }\n\n  if ('__getHandler' in method && typeof method.__getHandler === 'function') {\n    var handler = method.__getHandler();\n\n    invokeNullableMethod(handler, event);\n    return;\n  }\n\n  if (!('__nodeConfig' in method)) {\n    return;\n  }\n\n  var argMapping = method.__nodeConfig.argMapping;\n\n  if (!Array.isArray(argMapping)) {\n    return;\n  }\n\n  for (var _ref2 of argMapping.entries()) {\n    var _ref3 = _slicedToArray(_ref2, 2);\n\n    var index = _ref3[0];\n\n    var _ref3$ = _slicedToArray(_ref3[1], 2);\n\n    var key = _ref3$[0];\n    var value = _ref3$[1];\n\n    if (!(key in event.nativeEvent)) {\n      continue;\n    }\n\n    var nativeValue = event.nativeEvent[key];\n\n    if (value !== null && value !== void 0 && value.setValue) {\n      value.setValue(nativeValue);\n    } else {\n      method.__nodeConfig.argMapping[index] = [key, nativeValue];\n    }\n  }\n\n  return;\n}","map":{"version":3,"sources":["GestureHandler.ts"],"names":["State","UNDETERMINED","enabled","constructor","init","setView","findNodeHandle","setEventManager","setInteractionManager","onCancel","onReset","resetProgress","reset","moveToState","oldState","GestureHandlerOrchestrator","onStateChange","begin","fail","cancel","activate","_force","end","isAwaiting","setAwaiting","isActive","setActive","getShouldResetProgress","setShouldResetProgress","getActivationIndex","setActivationIndex","shouldWaitForHandlerFailure","handler","shouldRequireToWaitForFailure","shouldRecognizeSimultaneously","shouldBeCancelledByOther","onPointerDown","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerOut","onPointerEnter","onPointerCancel","onPointerOutOfBounds","tryToSendMoveEvent","out","onGestureHandlerStateChange","resultEvent","invokeNullableMethod","transformEventData","nativeEvent","numberOfPointers","state","pointerInside","x","event","y","handlerTag","target","newState","undefined","timeStamp","Date","transformNativeEvent","updateGestureConfig","props","checkCustomActivationCriteria","criterias","validateHitSlops","checkHitSlop","width","height","left","top","right","bottom","resetConfig","getTag","setTag","getConfig","getShouldEnableGestureOnSetup","getView","getEventManager","getTracker","getTrackedPointersID","getState","setShouldCancelWhenOutside","getShouldCancelWhenOutside","method","argMapping","Array","key","nativeValue","value"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { findNodeHandle } from 'react-native';\nimport { State } from '../../State';\nimport {\n  Config,\n  AdaptedPointerEvent,\n  PropsRef,\n  ResultEvent,\n} from '../interfaces';\nimport EventManager from '../tools/EventManager';\nimport GestureHandlerOrchestrator from '../tools/GestureHandlerOrchestrator';\nimport InteractionManager from '../tools/InteractionManager';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport default abstract class GestureHandler {\n  private lastSentState: State | null = null;\n  protected currentState: State = State.UNDETERMINED;\n\n  protected shouldCancellWhenOutside = false;\n  protected hasCustomActivationCriteria: boolean;\n  protected enabled = false;\n\n  private ref!: number;\n  private propsRef!: React.RefObject<unknown>;\n  protected config: Config = { enabled: false };\n  private handlerTag!: number;\n  protected view: HTMLElement | null = null;\n\n  protected eventManager!: EventManager;\n  protected tracker: PointerTracker = new PointerTracker();\n  protected interactionManager!: InteractionManager;\n\n  // Orchestrator properties\n  protected activationIndex = 0;\n  protected awaiting = false;\n  protected active = false;\n  protected shouldResetProgress = false;\n\n  public constructor() {\n    this.hasCustomActivationCriteria = false;\n  }\n\n  //\n  // Initializing handler\n  //\n\n  protected init(ref: number, propsRef: React.RefObject<unknown>) {\n    this.propsRef = propsRef;\n    this.ref = ref;\n\n    this.currentState = State.UNDETERMINED;\n\n    this.setView(ref);\n    this.setEventManager();\n  }\n\n  private setView(ref: number) {\n    if (!ref) {\n      this.view = null;\n      return;\n    }\n\n    this.view = (findNodeHandle(ref) as unknown) as HTMLElement;\n    this.view.style['touchAction'] = 'none';\n    this.view.style['webkitUserSelect'] = 'none';\n    this.view.style['userSelect'] = 'none';\n\n    //@ts-ignore This one disables default events on Safari\n    this.view.style['WebkitTouchCallout'] = 'none';\n  }\n\n  private setEventManager(): void {\n    if (!this.view) {\n      return;\n    }\n\n    this.eventManager = new EventManager(this.view);\n\n    this.eventManager.setOnPointerDown(this.onPointerDown.bind(this));\n    this.eventManager.setOnPointerUp(this.onPointerUp.bind(this));\n    this.eventManager.setOnPointerMove(this.onPointerMove.bind(this));\n    this.eventManager.setOnPointerEnter(this.onPointerEnter.bind(this));\n    this.eventManager.setOnPointerOut(this.onPointerOut.bind(this));\n    this.eventManager.setOnPointerCancel(this.onPointerCancel.bind(this));\n    this.eventManager.setOnPointerOutOfBounds(\n      this.onPointerOutOfBounds.bind(this)\n    );\n\n    this.eventManager.setListeners();\n  }\n\n  public setInteractionManager(manager: InteractionManager): void {\n    this.interactionManager = manager;\n  }\n\n  //\n  // Resetting handler\n  //\n\n  protected onCancel(): void {}\n  protected onReset(): void {}\n  protected resetProgress(): void {}\n\n  public reset(): void {\n    this.tracker.resetTracker();\n    this.onReset();\n    this.currentState = State.UNDETERMINED;\n  }\n\n  //\n  // State logic\n  //\n\n  public moveToState(newState: State, event: AdaptedPointerEvent) {\n    if (this.currentState === newState) {\n      return;\n    }\n\n    const oldState = this.currentState;\n    this.currentState = newState;\n\n    GestureHandlerOrchestrator.getInstance().onHandlerStateChange(\n      this,\n      newState,\n      oldState,\n      event\n    );\n\n    this.onStateChange(newState, oldState);\n  }\n\n  protected onStateChange(_newState: State, _oldState: State): void {}\n\n  public begin(event: AdaptedPointerEvent): void {\n    if (!this.checkHitSlop(event)) {\n      return;\n    }\n\n    if (this.currentState === State.UNDETERMINED) {\n      this.moveToState(State.BEGAN, event);\n    }\n  }\n\n  public fail(event: AdaptedPointerEvent): void {\n    if (\n      this.currentState === State.ACTIVE ||\n      this.currentState === State.BEGAN\n    ) {\n      this.moveToState(State.FAILED, event);\n    }\n\n    this.resetProgress();\n  }\n\n  public cancel(event: AdaptedPointerEvent): void {\n    if (\n      this.currentState === State.ACTIVE ||\n      this.currentState === State.UNDETERMINED ||\n      this.currentState === State.BEGAN\n    ) {\n      this.onCancel();\n      this.moveToState(State.CANCELLED, event);\n    }\n  }\n\n  protected activate(event: AdaptedPointerEvent, _force = false) {\n    if (\n      this.currentState === State.UNDETERMINED ||\n      this.currentState === State.BEGAN\n    ) {\n      this.moveToState(State.ACTIVE, event);\n    }\n  }\n\n  public end(event: AdaptedPointerEvent) {\n    if (\n      this.currentState === State.BEGAN ||\n      this.currentState === State.ACTIVE\n    ) {\n      this.moveToState(State.END, event);\n    }\n\n    this.resetProgress();\n  }\n\n  //\n  // Methods for orchestrator\n  //\n\n  public isAwaiting(): boolean {\n    return this.awaiting;\n  }\n  public setAwaiting(value: boolean): void {\n    this.awaiting = value;\n  }\n\n  public isActive(): boolean {\n    return this.active;\n  }\n  public setActive(value: boolean): void {\n    this.active = value;\n  }\n\n  public getShouldResetProgress(): boolean {\n    return this.shouldResetProgress;\n  }\n  public setShouldResetProgress(value: boolean): void {\n    this.shouldResetProgress = value;\n  }\n\n  public getActivationIndex(): number {\n    return this.activationIndex;\n  }\n  public setActivationIndex(value: number): void {\n    this.activationIndex = value;\n  }\n\n  public shouldWaitForHandlerFailure(handler: GestureHandler): boolean {\n    if (handler === this) {\n      return false;\n    }\n\n    return this.interactionManager.shouldWaitForHandlerFailure(this, handler);\n  }\n\n  public shouldRequireToWaitForFailure(handler: GestureHandler): boolean {\n    if (handler === this) {\n      return false;\n    }\n\n    return this.interactionManager.shouldRequireHandlerToWaitForFailure(\n      this,\n      handler\n    );\n  }\n\n  public shouldRecognizeSimultaneously(handler: GestureHandler): boolean {\n    if (handler === this) {\n      return true;\n    }\n\n    return this.interactionManager.shouldRecognizeSimultaneously(this, handler);\n  }\n\n  public shouldBeCancelledByOther(handler: GestureHandler): boolean {\n    if (handler === this) {\n      return false;\n    }\n\n    return this.interactionManager.shouldHandlerBeCancelledBy(this, handler);\n  }\n\n  //\n  // Event actions\n  //\n\n  protected onPointerDown(_event: AdaptedPointerEvent): void {\n    GestureHandlerOrchestrator.getInstance().recordHandlerIfNotPresent(this);\n  }\n  // Adding another pointer to existing ones\n  protected onPointerAdd(_event: AdaptedPointerEvent): void {}\n  protected onPointerUp(_event: AdaptedPointerEvent): void {}\n  // Removing pointer, when there is more than one pointers\n  protected onPointerRemove(_event: AdaptedPointerEvent): void {}\n  protected onPointerMove(event: AdaptedPointerEvent): void {\n    this.tryToSendMoveEvent(event, false);\n  }\n  protected onPointerOut(_event: AdaptedPointerEvent): void {}\n  protected onPointerEnter(_event: AdaptedPointerEvent): void {}\n  protected onPointerCancel(_event: AdaptedPointerEvent): void {}\n  protected onPointerOutOfBounds(event: AdaptedPointerEvent): void {\n    this.tryToSendMoveEvent(event, true);\n  }\n  private tryToSendMoveEvent(event: AdaptedPointerEvent, out: boolean): void {\n    if (\n      this.currentState === State.ACTIVE &&\n      (!out || (out && !this.shouldCancellWhenOutside))\n    ) {\n      this.sendEvent(event, this.currentState, this.currentState);\n    }\n  }\n\n  //\n  // Events Sending\n  //\n\n  public sendEvent = (\n    event: AdaptedPointerEvent,\n    newState: State,\n    oldState: State\n  ): void => {\n    const {\n      onGestureHandlerEvent,\n      onGestureHandlerStateChange,\n    }: PropsRef = this.propsRef.current as PropsRef;\n\n    const resultEvent: ResultEvent = this.transformEventData(\n      event,\n      newState,\n      oldState\n    );\n\n    // In the new API oldState field has to be undefined, unless we send event state changed\n    // Here the order is flipped to avoid workarounds such as making backup of the state and setting it to undefined first, then changing it back\n    // Flipping order with setting oldState to undefined solves issue, when events were being sent twice instead of once\n    // However, this may cause trouble in the future (but for now we don't know that)\n\n    if (this.lastSentState !== newState) {\n      this.lastSentState = newState;\n      invokeNullableMethod(onGestureHandlerStateChange, resultEvent);\n    }\n    if (this.currentState === State.ACTIVE) {\n      resultEvent.nativeEvent.oldState = undefined;\n      invokeNullableMethod(onGestureHandlerEvent, resultEvent);\n    }\n  };\n\n  private transformEventData(\n    event: AdaptedPointerEvent,\n    newState: State,\n    oldState: State\n  ): ResultEvent {\n    return {\n      nativeEvent: {\n        numberOfPointers: this.tracker.getTrackedPointersCount(),\n        state: newState,\n        pointerInside: this.eventManager?.isPointerInBounds({\n          x: event.x,\n          y: event.y,\n        }),\n        ...this.transformNativeEvent(event),\n        handlerTag: this.handlerTag,\n        target: this.ref,\n        oldState: newState !== oldState ? oldState : undefined,\n      },\n      timeStamp: Date.now(),\n    };\n  }\n\n  protected transformNativeEvent(_event: AdaptedPointerEvent) {\n    return {};\n  }\n\n  //\n  // Handling config\n  //\n\n  public updateGestureConfig({ enabled = true, ...props }): void {\n    this.config = { enabled, ...props };\n    this.validateHitSlops();\n  }\n\n  protected checkCustomActivationCriteria(criterias: string[]): void {\n    for (const key in this.config) {\n      if (criterias.indexOf(key) >= 0) {\n        this.hasCustomActivationCriteria = true;\n      }\n    }\n  }\n\n  private validateHitSlops(): void {\n    if (!this.config.hitSlop) {\n      return;\n    }\n\n    if (\n      this.config.hitSlop.left !== undefined &&\n      this.config.hitSlop.right !== undefined &&\n      this.config.hitSlop.width !== undefined\n    ) {\n      throw new Error(\n        'HitSlop Error: Cannot define left, right and width at the same time'\n      );\n    }\n\n    if (\n      this.config.hitSlop.width !== undefined &&\n      this.config.hitSlop.left === undefined &&\n      this.config.hitSlop.right === undefined\n    ) {\n      throw new Error(\n        'HitSlop Error: When width is defined, either left or right has to be defined'\n      );\n    }\n\n    if (\n      this.config.hitSlop.height !== undefined &&\n      this.config.hitSlop.top !== undefined &&\n      this.config.hitSlop.bottom !== undefined\n    ) {\n      throw new Error(\n        'HitSlop Error: Cannot define top, bottom and height at the same time'\n      );\n    }\n\n    if (\n      this.config.hitSlop.height !== undefined &&\n      this.config.hitSlop.top === undefined &&\n      this.config.hitSlop.bottom === undefined\n    ) {\n      throw new Error(\n        'HitSlop Error: When height is defined, either top or bottom has to be defined'\n      );\n    }\n  }\n\n  private checkHitSlop(event: AdaptedPointerEvent): boolean {\n    if (!this.config.hitSlop || !this.view) {\n      return true;\n    }\n\n    const width = this.view.getBoundingClientRect().width;\n    const height = this.view.getBoundingClientRect().height;\n\n    let left = 0;\n    let top = 0;\n    let right: number = width;\n    let bottom: number = height;\n\n    if (this.config.hitSlop.horizontal !== undefined) {\n      left -= this.config.hitSlop.horizontal;\n      right += this.config.hitSlop.horizontal;\n    }\n\n    if (this.config.hitSlop.vertical !== undefined) {\n      top -= this.config.hitSlop.vertical;\n      bottom += this.config.hitSlop.vertical;\n    }\n\n    if (this.config.hitSlop.left !== undefined) {\n      left = -this.config.hitSlop.left;\n    }\n\n    if (this.config.hitSlop.right !== undefined) {\n      right = width + this.config.hitSlop.right;\n    }\n\n    if (this.config.hitSlop.top !== undefined) {\n      top = -this.config.hitSlop.top;\n    }\n\n    if (this.config.hitSlop.bottom !== undefined) {\n      bottom = width + this.config.hitSlop.bottom;\n    }\n    if (this.config.hitSlop.width !== undefined) {\n      if (this.config.hitSlop.left !== undefined) {\n        right = left + this.config.hitSlop.width;\n      } else if (this.config.hitSlop.right !== undefined) {\n        left = right - this.config.hitSlop.width;\n      }\n    }\n\n    if (this.config.hitSlop.height !== undefined) {\n      if (this.config.hitSlop.top !== undefined) {\n        bottom = top + this.config.hitSlop.height;\n      } else if (this.config.hitSlop.bottom !== undefined) {\n        top = bottom - this.config.hitSlop.height;\n      }\n    }\n\n    if (\n      event.offsetX >= left &&\n      event.offsetX <= right &&\n      event.offsetY >= top &&\n      event.offsetY <= bottom\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  protected resetConfig(): void {}\n\n  //\n  // Getters and setters\n  //\n\n  public getTag(): number {\n    return this.handlerTag;\n  }\n  public setTag(tag: number): void {\n    this.handlerTag = tag;\n  }\n\n  protected getConfig() {\n    return this.config;\n  }\n\n  public getShouldEnableGestureOnSetup(): boolean {\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n  }\n\n  public getView(): HTMLElement | null {\n    return this.view;\n  }\n\n  public getEventManager(): EventManager {\n    return this.eventManager;\n  }\n\n  public getTracker(): PointerTracker {\n    return this.tracker;\n  }\n\n  public getTrackedPointersID(): number[] {\n    return this.tracker.getTrackedPointersID();\n  }\n\n  public getState(): State {\n    return this.currentState;\n  }\n\n  protected setShouldCancelWhenOutside(flag: boolean) {\n    this.shouldCancellWhenOutside = flag;\n  }\n  protected getShouldCancelWhenOutside(): boolean {\n    return this.shouldCancellWhenOutside;\n  }\n}\n\nfunction invokeNullableMethod(\n  method:\n    | ((event: ResultEvent) => void)\n    | { __getHandler: () => (event: ResultEvent) => void }\n    | { __nodeConfig: { argMapping: unknown[] } },\n  event: ResultEvent\n): void {\n  if (!method) {\n    return;\n  }\n\n  if (typeof method === 'function') {\n    method(event);\n    return;\n  }\n\n  if ('__getHandler' in method && typeof method.__getHandler === 'function') {\n    const handler = method.__getHandler();\n    invokeNullableMethod(handler, event);\n    return;\n  }\n\n  if (!('__nodeConfig' in method)) {\n    return;\n  }\n\n  const { argMapping } = method.__nodeConfig;\n  if (!Array.isArray(argMapping)) {\n    return;\n  }\n\n  for (const [index, [key, value]] of argMapping.entries()) {\n    if (!(key in event.nativeEvent)) {\n      continue;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const nativeValue = event.nativeEvent[key];\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (value?.setValue) {\n      //Reanimated API\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      value.setValue(nativeValue);\n    } else {\n      //RN Animated API\n      method.__nodeConfig.argMapping[index] = [key, nativeValue];\n    }\n  }\n\n  return;\n}\n"]},"metadata":{},"sourceType":"module"}